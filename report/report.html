<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="ReText 3.1.2">
  <title>report</title>
</head>
<body>
<h2>Запуск тестера</h2>
<p>Итак, мой тестер страниц расположен на <a href="https://github.com/karlicoss/webpagetester">github</a>. </p>
<p>Собирается он командой <code>mvn compile assembly:single</code>, в папке <code>target</code> будет лежать <code>webpagetester-1.0-jar-with-dependencies.jar</code>, который нам и нужен. У него есть несколько параметров:</p>
<ul>
<li><code>-c</code> или <code>--config</code>: пусть к properties файлу, в котором прописываются всякие параметры генераторов ввода. Если параметр не указан, используется <code>config.properties</code>, лежащий в текущей директории.</li>
<li><code>-d</code> или <code>--driver</code>: webdriver, который используется, возможные опции -- <code>chromed</code>, <code>firefox</code>, или <code>htmlunit</code></li>
<li><code>-o</code> или <code>--output</code>: папка, в которую будут скидываться отчеты по тестированию, если параметр не указан, будет использована текущая папка. Папка должна уже существовать.</li>
<li><code>-u</code> или <code>--url</code>: собственно, URL, который будет протестирован.</li>
</ul>
<p>Например: <code>java -jar webpagetester-1.0-jar-with-dependencies.jar -d "firefox" -o "reports" -u "http://twitter.com"</code></p>
<p>Соответственно после запуска произойдет извлечение ссылок в файл с именем вроде <code>"http___twitter.com.links"</code> и форм с данными для ввода в файл с именем <code>"http___twitter.com.forms"</code> (я заменяю всякие специальные символы нижним подчеркиванием, чтобы файл создавался без проблем).</p>
<h2>Описание работы</h2>
<p>В общем-то у меня происходит:</p>
<ol>
<li>Извлечение ссылок, все предельно тупо, извлекаются только ссылки типа <code>&lt;a href="..."&gt;</code>. Понятно, что для чего-то более нетривиального нужно как-то парсить js.</li>
<li>Извлечение форм и генерация данных для них.</li>
</ol>
<h3>Извлечение форм</h3>
<p>Под формой имеется в виду что-то, что независимо от остальных элементов на странице, и, соответственно, может тестироваться отдельно от всего остального, что сильно уменьшает число тестов. Почти всегда все, что находится в теге <code>&lt;form&gt;</code>, подходит под это определение (однако есть ислючения, например, сайт <code>vk.com</code>, об этом будет написано дальше), можно также попытаться конструировать формы из элементов ввода, лежащих вне тега <code>&lt;form&gt;</code>:</p>
<p><img src="forms_extraction.png" width="500"> </p>
<p>Будем извлекать формы из страницы рекурсивно, тогда когда мы перейдем к обработке тега <code>&lt;some tag&gt;</code>, обнаружим что у нас есть «настоящая» форма (тег <code>&lt;form&gt;</code>) и несколько элементов ввода, которые тоже объединим в форму.</p>
<p>Итак, получили поддеревья HTML-структуры страницы, соответствующие формам. Вообще говоря, формы и способ отправки данных серверу бывает разный (можно, например, ткнуть кнопку «submit», а можно -- нажать какую-то клавишу, и т.д.). Я обрабатываю только случай формы вида «ввели данные, нажали кнопку в форме», за это отвечает класс <code>forms.InputAndClickButtonForm</code>. </p>
<p>Далее, я предполагаю, что после загрузки страницы при работе с ней (т.е. вводе данных), ничего в нее динамически не подгружается (насколько я понимаю, это AJAX), а у элементов только меняются стили (в частности, мне интересен только случай «элемент стал видим/скрыт»). Здесь можно сделать какое-нибудь предположение вроде «видимость элемента зависит только от одного параметра» (чаще всего это так), тогда получаем граф-лес элементов ввода:</p>
<p><img src="dependent_inputs.png" width="500"></p>
<p>То есть, если мы хотим выбрать «MIT» из списка «Choose university», обязательно надо выбрать «University student» в списке «Your job», иначе элемент выбора университета будет невидимым.</p>
<p>Понятно, что вообще говоря, чтобы обнаружить такие зависимости, надо некоторое время исследовать страницу, т.е. перепробовать все поля в элементах с конечным числом вариантов (списки, чекбоксы, радиокнопки и т.п.), попробовать ввести хоть что-то в поля с бесконечным числом вариантов (т.е. поля ввода текста и паролей), и потыкать на различные активные элементы (ссылки, кнопки). Тут проблем несколько:</p>
<ol>
<li>В webdriver нет возможности поймать событие вроде «элемент пропал/стал видим», впрочем, учитывая, что элементов на странице не так много, можно тупо хранить отображение из элементов ввода в boolean, и просто каждый раз искать их и проверять, изменилось ли состояние.</li>
<li>Если вдруг после тыка на какую-нибудь кнопку начинается загрузка другой страницы, нет возможности узнать, что она началась (кроме сравнения изначальной и конечной сслыки, и то не факт -- страница может тупо загрузиться заново).</li>
<li>В webdriver нет возможности соответственно остановить или запретить переход на другую страницу.</li>
<li>
<p>Некоторые активные элементы вообще невозможно определить, не разбирая JS (например, на странице <a href="http://market.yandex.ru/guru.xml?CMD=-RR=0,0,0,0-VIS=70-CAT_ID=6427101-EXC=1-PG=10&amp;hid=6427100">яндекс-маркета</a> подчеркнутые пунктиром элементы -- активные, чего не скажешь по их HTML коду:</p>
<blockquote>
<p><img src="fail_activeelement.png"></p>
</blockquote>
</li>
<li>
<p>По ссылке типа <code>&lt;a href="..."&gt;</code> также невозможно понять, приведет ли она к загрузке новой страницы, например, аттрибут <code>href</code> ссылки «войти» на той же странице на первый взгляд должен вести на другую страницу, а он только отображает форму поверх текущей.</p>
</li>
</ol>
<p>По этим причинам я не смог добавить поддержку зависимостей между элементами, возможно, webdriver не подходит для такого? (хотя может быть, я чего-то не так понял в документации, которая у него, кстати, просто ужасная), и работаю только с видимыми изначально элементами в предположении что никакие элементы внезапно не пропадут (впрочем, для большинства страниц так и есть).</p>
<h3>Извлечение описаний для элементов ввода</h3>
<p>Сразу приведу пример проблемы с описанием элемента ввода:</p>
<p><img src="fail_urbandictionary.png"></p>
<p>Как назвать поле, которое слева от кнопки «subscribe», не сразу понятно даже человеку, только как-то по тому что кнопка называется «subscribe» можно догадаться, что от нас хотять email.</p>
<p>Но так уж и быть, предположим, что где-то рядом с элементом располагается надпись к нему, благо чаще всего так и есть. Мой алгоритм получения описания примерно такой:</p>
<ul>
<li>Если что-то есть в атрибуте <code>title</code> (насколько я понимаю, отвечает за всплывающую подсказку), очень вероятно, что оно совпадет с надписью, соответствующей элементу.</li>
<li>Часто можно извлечь информацию из атрибута <code>value</code>, в особенности для кнопок.</li>
<li>Выпадающие списки можно найти по варианту по умолчанию (атрибут <code>selected</code>).</li>
<li>
<p>Элемент и надпись могут разделять общий тег:</p>
<blockquote>
<p><code>&lt;some tag&gt;Label1: &lt;input element1&gt;&lt;/some tag&gt;</code></p>
<p><code>&lt;some tag&gt;Label2: &lt;input element2&gt;&lt;/some tag&gt;</code></p>
</blockquote>
<p>Этот случай обрабатывается подъемом к родительскому элементу, проверкой есть ли какой-то текст внутри него, и так поднимаемся, пока не обнаружим какой-то текст. </p>
</li>
<li>
<p>Плохой случай -- элемент и надпись не разделяют общий тег, такая верстка очень распространена:</p>
<blockquote>
<p><code>&lt;div&gt;Label1:&lt;/div&gt; &lt;input element1&gt;</code></p>
<p><code>&lt;div&gt;Lavel2:&lt;/div&gt; &lt;input element2&gt;</code></p>
</blockquote>
<p>В этом случае вообще говоря непонятно, что делать, потому что надпись может быть и слева, а может быть и справа, в общем у меня он обрабатывается так же, как предыдущий случай, то есть будет выводить кучу надписей сразу с переводами на новые строки и т.д. Я бы мог обнаруживать этот случай и говорить, что ничего не буду генерировать, так как не могу определить надпись, но решил, что пусть хоть так будет.</p>
</li>
<li>
<p>И самый фиговый и тоже довольно распространенный случай:</p>
<blockquote>
<p><img src="fail_arxiv.png"></p>
</blockquote>
<p>Надпись «Search or Article-id» на сайте arxiv.org в HTML-коде насположена на несколько тегов позади собственно поля, поэтому вообще неясно, как программно можно обнаружить что чему соотвествует, не видя как оно рендерится. Такое тоже у меня никак не обрабатывается.</p>
</li>
</ul>
<h2>Альтернативный способ извлечения описаний к полям ввода</h2>
<p>Альтернативой анализу HTML кода для извлечения форм и описаний к элементам ввода может быть распознавание скриншота страницы. Я почти не знаком с алгоритмами распознавания чего-либо, но раз распознают рукописный текст, распознать чекбоксы, радиокнопки, поля ввода, выпадающие списки и блоки текста находящиеся рядом должно быть очень просто. Тогда получаем что-то такое:</p>
<p><img src="form_recognition_fb.png"></p>
<p>Во-первых, становится просто определять форму как скопление рядов стоящих элементов ввода, то есть отпадает проблема поиска форм, сделанных не с помощью тега <code>&lt;form&gt;</code>, а с помощью js, или даже flash. </p>
<p>Во-вторых, становится проще искать надписи -- понятно что если у элемента есть надпись, она где-то рядом с ним, тогда задача состоит в том, чтобы сопоставить элеменам ввода одну из стоящих рядом надписей. Можно представить элементы и надписи как доли графа, и сопоставить стоимости ребра из элемента в надпись какой-нибудь функции. Можно предположить какие-то логичные свойства:</p>
<ul>
<li>Чем ближе элемент и надпись, тем больше шанс что они относятся друг к другу.</li>
<li>Если надпись внутри элемента, но они почти наверняка относятся друг к другу (во всяком случае, элемент легко можно по такой надписи отыскать)</li>
<li>Надпись скорее расположена слева, чем справа (хотя у чекбоксов чаще справа), и скорее сверху, чем снизу.</li>
</ul>
<p>Ну и дальше применить какой-нибудь алгоритм поиска паросочетания максимального/минимального веса.</p>
<p>Насколько я понимаю, по координате элемента на экране определить, к какому тегу html он относится, можно (Inspector в chrome так умеет, во всяком случае), но webdriver, видимо, этого не умеет.</p>
<h2>Целесообразность заполнения полей человеком</h2>
<p>Мы генерируем инструкцию для человека, возможно, будет проще если тыканье в кнопки/ссылки и заполнение полей будет все же делать программа, а человек будет только наблюдать, и фиксировать когда происходит что-то странное, тогда отпадают проблемы:</p>
<ul>
<li>Необходимости генерации нормальных описаний к полям.</li>
<li>Вводить человеку какие-то нетрививальные последовательности символов -- совершенно неудобно и медленно.</li>
<li>К примеру, в элементе ввода <code>&lt;input type="image"&gt;</code> входные данные -- координата клика, нет никакой возможности сообщить тестеру, куда точно надо ткнуть, программа может это тупо передать в запросе.</li>
<li>Если на экране есть несколько полей/кнопок/ссылок с одинаковым названием, нет возможности сообщить тестеру, в какую из них ткнуть. </li>
</ul>
<h2>Некоторые странности webdriver, с которыми я не умею бороться:</h2>
<ul>
<li>Если ввести какой-нибудь некорректный url, например, "http://aaa", драйвера пытаются автодополнять его до "http://aaa.com", либо просто отображают стандартную страницу, говорящую о том, что такого URL нет, которую webdriver проглатывает как корректную. Таким образом не особо понятно, как обрабатывать некорректный ввод URL. Более того, если ввести какой-нибудь треш вроде "dfsfsf", даже без протокола, WebDriver бросает какое-то странное исключение, ничего не говорящее о том, что именно плохо.</li>
<li><code>HtmlUnitDriver</code> вообще не считает, что какие-то элементы могут быть скрытыми, то есть <code>isDisplayed()</code> всегда <code>true</code>. Еще он ужасно засоряет stderr какими-то проблемами с парсингом CSS.</li>
<li>На странице vk.com есть кнопка с <code>id="reg_bar_btn"</code>, которая на странице не отображается, однако код <code>driver.findElement(By.id("reg_bar_btn")).isDisplayed()</code> возвращает <code>true</code>. (хотя, может, и верстальщик виноват)</li>
<li>Там же в форме входа кнопка отправки, которая <code>&lt;input type="submit"&gt;</code> не отображается и находится вообще фиг знает где, хотя webdriver считает, что отображается. (опять же, может, проблема в верстке)</li>
<li>
<p>И наоборот, какая-то непонятная проблема на страницах Яндекса: и <code>ChromeDriver</code>, и <code>FirefoxDriver</code> считают, что кнопки не отображаются (т.е. <code>isDisplayed() == false</code>), хотя, например, «Войти» замечательно отображается:</p>
<blockquote>
<p><img src="fail_yandex.png"></p>
</blockquote>
</li>
</ul>
<h2>Некоторые вещи, которые я не понимаю в верстке:</h2>
<ul>
<li>Я вообще не очень понимаю принцип, по которому верстают формы, иногда на одной и той же странице некоторые формы в теге <code>&lt;form&gt;</code>, а в остальных -- элементы просто вразнобой. Более того, есть сайты, на которых данные, находящиеся в теге <code>&lt;form&gt;</code>, отправляются кнопкой, которая вообще находится вне этого тега (например, <code>vk.com</code>).</li>
<li>Хорошей идеей для верстальщика было бы использовать аттрибут «for» тега label, который придуман специально чтобы указывать, к чему относится надпись, только почему-то его все равно никто не использует.</li>
<li>Также есть много замечательных HTML5 элементов вроде email, datetime, tel и т.д., но их все равно почему-то не используют, вместо <code>month</code> юзают <code>select</code> с числами от 1 до 31, и т.д. Собственно, поэтому я не стал создавать для них классы и генераторы, хотя добавляются они относительно легко.</li>
</ul>
<p>Возможно это все происходит потому-то страницы генерируются как-то по-хитрому и автоматически, но я не удивлюсь, если все же проблема в верстальщиках.</p>
<h2>Некоторые замечания по поводу моего кода:</h2>
<ul>
<li>Я ловлю все исключения в <code>WebPageTester.main</code> и просто вывожу стектрейс, все равно тот, кто пользуется тестером, будет вызывать его как отдельную программу и не сможет обработать исключения.</li>
<li>Сначала HTML страница представляет у меня просто дерево из элементов <code>WebNode</code>, некоторые из которых я по ходу программы преобразую в <code>InputElement</code>. Для этого я использую метод <code>makeInput</code> фабрики <code>InputElementFactory</code>. Также иногда нужно просто определять, является ли элемент элементом ввода с помощью метода <code>isInput</code> (это часто быстрее чем делать элемент и проверять, что он, например, не <code>null</code>). Тут приходится делать в некотором смысле дублирование кода и неясно, как держать методы <code>isInput</code> и <code>makeInput</code> согласованными. Возможно, стоит использовать рефлексию, а, может, есть какой-то паттерн для подобного, в общем, я не знаю.</li>
<li>Я вообще не уверен, что правильно использую здесь паттерн фабрики, так как это делаю чуть ли не в первый раз, но вроде получилось нормально. Но во всяком случае, если кто-нибудь решит, например, сделать не <code>UniformInputGeneratorFactory</code>, а какую-нибудь другую, он сможет легко отнаследоваться от <code>InputGeneratorFactory</code> и написать что-то свое. С другой стороны, мне не очень нравится, что приходится использовать приведение типов вниз, но, может, этого и не избежать.</li>
</ul>
</body>
</html>
